"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.stream_from_info = exports.stream = exports.parseAudioFormats = exports.StreamType = void 0;
const _1 = require(".");
const LiveStream_1 = require("./classes/LiveStream");
var StreamType;
(function (StreamType) {
    StreamType["Arbitrary"] = "arbitrary";
    StreamType["Raw"] = "raw";
    StreamType["OggOpus"] = "ogg/opus";
    StreamType["WebmOpus"] = "webm/opus";
    StreamType["Opus"] = "opus";
})(StreamType = exports.StreamType || (exports.StreamType = {}));
/**
 * Command to find audio formats from given format array
 * @param formats Formats to search from
 * @returns Audio Formats array
 */
function parseAudioFormats(formats) {
    const result = [];
    formats.forEach((format) => {
        const type = format.mimeType;
        if (type.startsWith('audio')) {
            format.codec = type.split('codecs="')[1].split('"')[0];
            format.container = type.split('audio/')[1].split(';')[0];
            result.push(format);
        }
    });
    return result;
}
exports.parseAudioFormats = parseAudioFormats;
/**
 * Stream command for YouTube
 * @param url YouTube URL
 * @param options lets you add quality, cookie, proxy support for stream
 * @returns Stream class with type and stream for playing.
 */
async function stream(url, options = {}) {
    const info = await (0, _1.video_info)(url, { proxy: options.proxy, htmldata: options.htmldata });
    const final = [];
    if (info.LiveStreamData.isLive === true &&
        info.LiveStreamData.hlsManifestUrl !== null &&
        info.video_details.durationInSec === 0) {
        return new LiveStream_1.LiveStreaming(info.LiveStreamData.dashManifestUrl, info.format[info.format.length - 1].targetDurationSec, info.video_details.url);
    }
    const audioFormat = parseAudioFormats(info.format);
    if (typeof options.quality !== 'number')
        options.quality = audioFormat.length - 1;
    else if (options.quality <= 0)
        options.quality = 0;
    else if (options.quality >= audioFormat.length)
        options.quality = audioFormat.length - 1;
    if (audioFormat.length !== 0)
        final.push(audioFormat[options.quality]);
    else
        final.push(info.format[info.format.length - 1]);
    let type = final[0].codec === 'opus' && final[0].container === 'webm' ? StreamType.WebmOpus : StreamType.Arbitrary;
    return new LiveStream_1.Stream(final[0].url, type, info.video_details.durationInSec, Number(final[0].contentLength), info.video_details.url, options);
}
exports.stream = stream;
/**
 * Stream command for YouTube using info from video_info or decipher_info function.
 * @param info video_info data
 * @param options lets you add quality, cookie, proxy support for stream
 * @returns Stream class with type and stream for playing.
 */
async function stream_from_info(info, options = {}) {
    const final = [];
    if (info.LiveStreamData.isLive === true &&
        info.LiveStreamData.hlsManifestUrl !== null &&
        info.video_details.durationInSec === 0) {
        return new LiveStream_1.LiveStreaming(info.LiveStreamData.dashManifestUrl, info.format[info.format.length - 1].targetDurationSec, info.video_details.url);
    }
    const audioFormat = parseAudioFormats(info.format);
    if (typeof options.quality !== 'number')
        options.quality = audioFormat.length - 1;
    else if (options.quality <= 0)
        options.quality = 0;
    else if (options.quality >= audioFormat.length)
        options.quality = audioFormat.length - 1;
    if (audioFormat.length !== 0)
        final.push(audioFormat[options.quality]);
    else
        final.push(info.format[info.format.length - 1]);
    let type = final[0].codec === 'opus' && final[0].container === 'webm' ? StreamType.WebmOpus : StreamType.Arbitrary;
    return new LiveStream_1.Stream(final[0].url, type, info.video_details.durationInSec, Number(final[0].contentLength), info.video_details.url, options);
}
exports.stream_from_info = stream_from_info;
//# sourceMappingURL=stream.js.map