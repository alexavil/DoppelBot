"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createVoiceReceiver = exports.VoiceReceiver = void 0;
const AudioPlayer_1 = require("../audio/AudioPlayer");
const Secretbox_1 = require("../util/Secretbox");
const AudioReceiveStream_1 = require("./AudioReceiveStream");
const SSRCMap_1 = require("./SSRCMap");
/**
 * Attaches to a VoiceConnection, allowing you to receive audio packets from other
 * users that are speaking.
 *
 * @beta
 */
class VoiceReceiver {
    constructor(voiceConnection) {
        this.voiceConnection = voiceConnection;
        this.ssrcMap = new SSRCMap_1.SSRCMap();
        this.subscriptions = new Map();
        this.connectionData = {};
        const onWsPacket = (packet) => this.onWsPacket(packet);
        const onUdpMessage = (msg) => this.onUdpMessage(msg);
        const applyConnectionData = (connectionData) => {
            this.connectionData = {
                ...this.connectionData,
                ...connectionData,
            };
            if (connectionData.packetsPlayed === 0) {
                this.voiceConnection.playOpusPacket(AudioPlayer_1.SILENCE_FRAME);
            }
        };
        // Bind listeners for updates
        const onNetworkingChange = (oldState, newState) => {
            const oldWs = Reflect.get(oldState, 'ws');
            const oldUdp = Reflect.get(oldState, 'udp');
            const newWs = Reflect.get(newState, 'ws');
            const newUdp = Reflect.get(newState, 'udp');
            const connectionData = Reflect.get(newState, 'connectionData');
            if (connectionData)
                applyConnectionData(connectionData);
            if (newWs !== oldWs) {
                oldWs === null || oldWs === void 0 ? void 0 : oldWs.off('packet', onWsPacket);
                newWs === null || newWs === void 0 ? void 0 : newWs.on('packet', onWsPacket);
            }
            if (newUdp !== oldUdp) {
                oldUdp === null || oldUdp === void 0 ? void 0 : oldUdp.off('message', onUdpMessage);
                newUdp === null || newUdp === void 0 ? void 0 : newUdp.on('message', onUdpMessage);
            }
        };
        this.voiceConnection.on('stateChange', (oldState, newState) => {
            const oldNetworking = Reflect.get(oldState, 'networking');
            const newNetworking = Reflect.get(newState, 'networking');
            if (newNetworking !== oldNetworking) {
                oldNetworking === null || oldNetworking === void 0 ? void 0 : oldNetworking.off('stateChange', onNetworkingChange);
                newNetworking === null || newNetworking === void 0 ? void 0 : newNetworking.on('stateChange', onNetworkingChange);
                if (newNetworking) {
                    const ws = Reflect.get(newNetworking.state, 'ws');
                    const udp = Reflect.get(newNetworking.state, 'udp');
                    const connectionData = Reflect.get(newNetworking.state, 'connectionData');
                    ws === null || ws === void 0 ? void 0 : ws.on('packet', onWsPacket);
                    udp === null || udp === void 0 ? void 0 : udp.on('message', onUdpMessage);
                    if (connectionData)
                        applyConnectionData(connectionData);
                }
            }
        });
        // Bind listeners for the existing state
        const networking = Reflect.get(voiceConnection.state, 'networking');
        if (networking) {
            const ws = Reflect.get(networking.state, 'ws');
            const udp = Reflect.get(networking.state, 'udp');
            const connectionData = Reflect.get(networking.state, 'connectionData');
            ws === null || ws === void 0 ? void 0 : ws.on('packet', onWsPacket);
            udp === null || udp === void 0 ? void 0 : udp.on('message', onUdpMessage);
            if (connectionData)
                applyConnectionData(connectionData);
        }
    }
    /**
     * Called when a packet is received on the attached connection's WebSocket.
     *
     * @param packet The received packet
     */
    onWsPacket(packet) {
        var _a, _b, _c, _d, _e;
        if (packet.op === 13 /* ClientDisconnect */ && typeof ((_a = packet.d) === null || _a === void 0 ? void 0 : _a.user_id) === 'string') {
            this.ssrcMap.delete(packet.d.user_id);
        }
        else if (packet.op === 5 /* Speaking */ &&
            typeof ((_b = packet.d) === null || _b === void 0 ? void 0 : _b.user_id) === 'string' &&
            typeof ((_c = packet.d) === null || _c === void 0 ? void 0 : _c.ssrc) === 'number') {
            this.ssrcMap.update({ userId: packet.d.user_id, audioSSRC: packet.d.ssrc });
        }
        else if (packet.op === 12 /* ClientConnect */ &&
            typeof ((_d = packet.d) === null || _d === void 0 ? void 0 : _d.user_id) === 'string' &&
            typeof ((_e = packet.d) === null || _e === void 0 ? void 0 : _e.audio_ssrc) === 'number') {
            this.ssrcMap.update({
                userId: packet.d.user_id,
                audioSSRC: packet.d.audio_ssrc,
                videoSSRC: packet.d.video_ssrc === 0 ? undefined : packet.d.video_ssrc,
            });
        }
    }
    decrypt(buffer, mode, nonce, secretKey) {
        // Choose correct nonce depending on encryption
        let end;
        if (mode === 'xsalsa20_poly1305_lite') {
            buffer.copy(nonce, 0, buffer.length - 4);
            end = buffer.length - 4;
        }
        else if (mode === 'xsalsa20_poly1305_suffix') {
            buffer.copy(nonce, 0, buffer.length - 24);
            end = buffer.length - 24;
        }
        else {
            buffer.copy(nonce, 0, 0, 12);
        }
        // Open packet
        const decrypted = Secretbox_1.methods.open(buffer.slice(12, end), nonce, secretKey);
        if (!decrypted)
            return;
        return Buffer.from(decrypted);
    }
    /**
     * Parses an audio packet, decrypting it to yield an Opus packet.
     *
     * @param buffer The buffer to parse
     * @param mode The encryption mode
     * @param nonce The nonce buffer used by the connection for encryption
     * @param secretKey The secret key used by the connection for encryption
     * @returns The parsed Opus packet
     */
    parsePacket(buffer, mode, nonce, secretKey) {
        let packet = this.decrypt(buffer, mode, nonce, secretKey);
        if (!packet)
            return;
        // Strip RTP Header Extensions (one-byte only)
        if (packet[0] === 0xbe && packet[1] === 0xde && packet.length > 4) {
            const headerExtensionLength = packet.readUInt16BE(2);
            let offset = 4;
            for (let i = 0; i < headerExtensionLength; i++) {
                const byte = packet[offset];
                offset++;
                if (byte === 0)
                    continue;
                offset += 1 + (byte >> 4);
            }
            // Skip over undocumented Discord byte (if present)
            const byte = packet.readUInt8(offset);
            if (byte === 0x00 || byte === 0x02)
                offset++;
            packet = packet.slice(offset);
        }
        return packet;
    }
    /**
     * Called when the UDP socket of the attached connection receives a message.
     *
     * @param msg The received message
     */
    onUdpMessage(msg) {
        if (msg.length <= 8)
            return;
        const ssrc = msg.readUInt32BE(8);
        const stream = this.subscriptions.get(ssrc);
        if (!stream)
            return;
        const userData = this.ssrcMap.get(ssrc);
        if (!userData)
            return;
        if (this.connectionData.encryptionMode && this.connectionData.nonceBuffer && this.connectionData.secretKey) {
            const packet = this.parsePacket(msg, this.connectionData.encryptionMode, this.connectionData.nonceBuffer, this.connectionData.secretKey);
            if (packet) {
                stream.push(packet);
            }
            else {
                stream.destroy(new Error('Failed to parse packet'));
            }
        }
    }
    /**
     * Creates a subscription for the given target, specified either by their SSRC or user ID.
     *
     * @param target The audio SSRC or user ID to subscribe to
     * @returns A readable stream of Opus packets received from the target
     */
    subscribe(target) {
        var _a;
        const ssrc = (_a = this.ssrcMap.get(target)) === null || _a === void 0 ? void 0 : _a.audioSSRC;
        if (!ssrc) {
            throw new Error(`No known SSRC for ${target}`);
        }
        const existing = this.subscriptions.get(ssrc);
        if (existing)
            return existing;
        const stream = new AudioReceiveStream_1.AudioReceiveStream();
        stream.once('close', () => this.subscriptions.delete(ssrc));
        this.subscriptions.set(ssrc, stream);
        return stream;
    }
}
exports.VoiceReceiver = VoiceReceiver;
/**
 * Creates a new voice receiver for the given voice connection.
 *
 * @param voiceConnection The voice connection to attach to
 * @beta
 * @remarks
 * Voice receive is an undocumented part of the Discord API - voice receive is not guaranteed
 * to be stable and may break without notice.
 */
function createVoiceReceiver(voiceConnection) {
    return new VoiceReceiver(voiceConnection);
}
exports.createVoiceReceiver = createVoiceReceiver;
//# sourceMappingURL=VoiceReceiver.js.map