"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Timer = exports.Stream = exports.LiveStreaming = void 0;
const node_stream_1 = require("node:stream");
const stream_1 = require("../stream");
const Request_1 = require("../../Request");
const __1 = require("..");
class LiveStreaming {
    constructor(dash_url, target_interval, video_url) {
        this.stream = new node_stream_1.Readable({ highWaterMark: 10 * 1000 * 1000, read() { } });
        this.type = stream_1.StreamType.Arbitrary;
        this.url = dash_url;
        this.base_url = '';
        this.segments_urls = [];
        this.packet_count = 0;
        this.request = null;
        this.video_url = video_url;
        this.interval = target_interval || 0;
        this.timer = new Timer(() => {
            this.start();
        }, this.interval);
        this.dash_timer = new Timer(() => {
            this.dash_timer.reuse();
            this.dash_updater();
        }, 1800);
        this.stream.on('close', () => {
            this.cleanup();
        });
        this.start();
    }
    async dash_updater() {
        const info = await (0, __1.video_info)(this.video_url);
        if (info.LiveStreamData.isLive === true &&
            info.LiveStreamData.hlsManifestUrl !== null &&
            info.video_details.durationInSec === 0) {
            this.url = info.LiveStreamData.dashManifestUrl;
        }
    }
    async dash_getter() {
        const response = await (0, Request_1.request)(this.url);
        const audioFormat = response
            .split('<AdaptationSet id="0"')[1]
            .split('</AdaptationSet>')[0]
            .split('</Representation>');
        if (audioFormat[audioFormat.length - 1] === '')
            audioFormat.pop();
        this.base_url = audioFormat[audioFormat.length - 1].split('<BaseURL>')[1].split('</BaseURL>')[0];
        const list = audioFormat[audioFormat.length - 1].split('<SegmentList>')[1].split('</SegmentList>')[0];
        this.segments_urls = list.replace(new RegExp('<SegmentURL media="', 'g'), '').split('"/>');
        if (this.segments_urls[this.segments_urls.length - 1] === '')
            this.segments_urls.pop();
    }
    cleanup() {
        this.timer.destroy();
        this.dash_timer.destroy();
        this.request?.destroy();
        this.video_url = '';
        this.request = null;
        this.url = '';
        this.base_url = '';
        this.segments_urls = [];
        this.packet_count = 0;
        this.interval = 0;
    }
    async start() {
        if (this.stream.destroyed) {
            this.cleanup();
            return;
        }
        await this.dash_getter();
        if (this.segments_urls.length > 3)
            this.segments_urls.splice(0, this.segments_urls.length - 3);
        if (this.packet_count === 0)
            this.packet_count = Number(this.segments_urls[0].split('sq/')[1].split('/')[0]);
        for await (const segment of this.segments_urls) {
            if (Number(segment.split('sq/')[1].split('/')[0]) !== this.packet_count) {
                continue;
            }
            await new Promise(async (resolve, reject) => {
                const stream = await (0, Request_1.request_stream)(this.base_url + segment).catch((err) => err);
                if (stream instanceof Error) {
                    this.stream.emit('error', stream);
                    return;
                }
                this.request = stream;
                stream.on('data', (c) => {
                    this.stream.push(c);
                });
                stream.on('end', () => {
                    this.packet_count++;
                    resolve('');
                });
                stream.once('error', (err) => {
                    this.stream.emit('error', err);
                });
            });
        }
        this.timer.reuse();
    }
    pause() { }
    resume() { }
}
exports.LiveStreaming = LiveStreaming;
/**
 * Class for YouTube Stream
 */
class Stream {
    constructor(url, type, duration, contentLength, video_url, options) {
        this.stream = new node_stream_1.Readable({ highWaterMark: 10 * 1000 * 1000, read() { } });
        this.url = url;
        this.quality = options.quality;
        this.proxy = options.proxy || undefined;
        this.type = type;
        this.bytes_count = 0;
        this.video_url = video_url;
        this.per_sec_bytes = Math.ceil(contentLength / duration);
        this.content_length = contentLength;
        this.request = null;
        this.timer = new Timer(() => {
            this.timer.reuse();
            this.loop();
        }, 265);
        this.stream.on('close', () => {
            this.timer.destroy();
            this.cleanup();
        });
        this.loop();
    }
    async retry() {
        const info = await (0, __1.video_info)(this.video_url, { proxy: this.proxy });
        const audioFormat = (0, stream_1.parseAudioFormats)(info.format);
        this.url = audioFormat[this.quality].url;
    }
    cleanup() {
        this.request?.destroy();
        this.request = null;
        this.url = '';
    }
    async loop() {
        if (this.stream.destroyed) {
            this.timer.destroy();
            this.cleanup();
            return;
        }
        const end = this.bytes_count + this.per_sec_bytes * 300;
        const stream = await (0, Request_1.request_stream)(this.url, {
            headers: {
                range: `bytes=${this.bytes_count}-${end >= this.content_length ? '' : end}`
            }
        }).catch((err) => err);
        if (stream instanceof Error) {
            this.stream.emit('error', stream);
            this.bytes_count = 0;
            this.per_sec_bytes = 0;
            this.cleanup();
            return;
        }
        if (Number(stream.statusCode) >= 400) {
            this.cleanup();
            await this.retry();
            this.timer.reuse();
            this.loop();
            return;
        }
        this.request = stream;
        stream.on('data', (c) => {
            this.stream.push(c);
        });
        stream.once('error', async () => {
            this.cleanup();
            await this.retry();
            this.timer.reuse();
            this.loop();
        });
        stream.on('data', (chunk) => {
            this.bytes_count += chunk.length;
        });
        stream.on('end', () => {
            if (end >= this.content_length) {
                this.timer.destroy();
                this.stream.push(null);
                this.cleanup();
            }
        });
    }
    pause() {
        this.timer.pause();
    }
    resume() {
        this.timer.resume();
    }
}
exports.Stream = Stream;
class Timer {
    constructor(callback, time) {
        this.callback = callback;
        this.time_total = time;
        this.time_left = time;
        this.paused = false;
        this.destroyed = false;
        this.time_start = process.hrtime()[0];
        this.timer = setTimeout(this.callback, this.time_total * 1000);
    }
    pause() {
        if (!this.paused && !this.destroyed) {
            this.paused = true;
            clearTimeout(this.timer);
            this.time_left = this.time_left - (process.hrtime()[0] - this.time_start);
            return true;
        }
        else
            return false;
    }
    resume() {
        if (this.paused && !this.destroyed) {
            this.paused = false;
            this.time_start = process.hrtime()[0];
            this.timer = setTimeout(this.callback, this.time_left * 1000);
            return true;
        }
        else
            return false;
    }
    reuse() {
        if (!this.destroyed) {
            clearTimeout(this.timer);
            this.time_left = this.time_total;
            this.paused = false;
            this.time_start = process.hrtime()[0];
            this.timer = setTimeout(this.callback, this.time_total * 1000);
            return true;
        }
        else
            return false;
    }
    destroy() {
        clearTimeout(this.timer);
        this.destroyed = true;
        this.callback = () => { };
        this.time_total = 0;
        this.time_left = 0;
        this.paused = false;
        this.time_start = 0;
    }
}
exports.Timer = Timer;
//# sourceMappingURL=LiveStream.js.map