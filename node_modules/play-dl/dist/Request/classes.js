"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Proxy = void 0;
const node_tls_1 = __importDefault(require("node:tls"));
class Proxy {
    constructor(parsed_url, options) {
        this.parsed_url = parsed_url;
        this.sentHeaders = '';
        this.statusCode = 0;
        this.rawHeaders = '';
        this.body = '';
        this.headers = {};
        this.options = options;
        this.socket = node_tls_1.default.connect({
            host: this.parsed_url.hostname,
            port: Number(this.parsed_url.port) || 443,
            socket: options.socket,
            rejectUnauthorized: false
        }, () => this.onConnect());
        if (options.headers) {
            for (const [key, value] of Object.entries(options.headers)) {
                this.sentHeaders += `${key}: ${value}\r\n`;
            }
        }
    }
    onConnect() {
        this.socket.write(`${this.options.method} ${this.parsed_url.pathname}${this.parsed_url.search} HTTP/1.1\r\n` +
            `Host: ${this.parsed_url.hostname}\r\n` +
            this.sentHeaders +
            `Connection: close\r\n` +
            `\r\n`);
    }
    parseHeaders() {
        const head_arr = this.rawHeaders.split('\r\n');
        this.statusCode = Number(head_arr.shift()?.split(' ')[1]) ?? -1;
        for (const head of head_arr) {
            let [key, value] = head.split(': ');
            if (!value)
                break;
            key = key.trim().toLowerCase();
            value = value.trim();
            if (Object.keys(this.headers).includes(key)) {
                let val = this.headers[key];
                if (typeof val === 'string')
                    val = [val];
                Object.assign(this.headers, { [key]: [...val, value] });
            }
            else
                Object.assign(this.headers, { [key]: value });
        }
    }
    fetch() {
        return new Promise((resolve, reject) => {
            this.socket.setEncoding('utf-8');
            this.socket.once('error', (err) => reject(err));
            const parts = [];
            this.socket.on('data', (chunk) => {
                if (this.rawHeaders.length === 0) {
                    this.rawHeaders = chunk;
                    this.parseHeaders();
                }
                else {
                    const arr = chunk.split('\r\n');
                    if (arr.length > 1 && arr[0].length < 5)
                        arr.shift();
                    parts.push(...arr);
                }
            });
            this.socket.on('end', () => {
                this.body = parts.join('');
                resolve(this);
            });
        });
    }
}
exports.Proxy = Proxy;
//# sourceMappingURL=classes.js.map